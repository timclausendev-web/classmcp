/**
 * Class Minification Engine
 * Generates ultra-short class names for maximum token savings
 *
 * Token Savings Example:
 * Original: class="inline-flex items-center justify-center px-4 py-2 bg-blue-600 text-white"
 * Minified: class="a"
 * Savings: ~80 tokens per usage
 */

import { MinificationMap, MinifiedClass } from '../types.js';

// Characters for minified names (ordered by frequency-safe chars)
// Using a-z first, then A-Z, avoiding i, l, o, I, O to prevent confusion
const SAFE_CHARS = 'abcdefghjkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ';
const EXTENDED_CHARS = 'abcdefghjkmnpqrstuvwxyz0123456789ABCDEFGHJKLMNPQRSTUVWXYZ';

/**
 * Simple hash function for class deduplication
 */
export function hashClasses(classes: string): string {
  let hash = 0;
  const normalized = classes.split(/\s+/).sort().join(' ');
  for (let i = 0; i < normalized.length; i++) {
    const char = normalized.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return Math.abs(hash).toString(36);
}

/**
 * Generate sequential minified names
 * a, b, c, ... z, A, B, ... Z, aa, ab, ac, ...
 */
export function generateMinifiedName(counter: number): string {
  const firstCharSet = SAFE_CHARS;
  const restCharSet = EXTENDED_CHARS;

  if (counter < firstCharSet.length) {
    return firstCharSet[counter];
  }

  // Multi-character names
  let result = '';
  let remaining = counter;

  // First character (must start with letter)
  result = firstCharSet[remaining % firstCharSet.length];
  remaining = Math.floor(remaining / firstCharSet.length);

  while (remaining > 0) {
    remaining -= 1; // Adjust for 1-indexed system
    result = restCharSet[remaining % restCharSet.length] + result;
    remaining = Math.floor(remaining / restCharSet.length);
  }

  return result;
}

/**
 * Create a new minification map
 */
export function createMinificationMap(): MinificationMap {
  return {
    nameToMinified: new Map(),
    minifiedToData: new Map(),
    usedNames: new Set(),
    counter: 0
  };
}

/**
 * Add a class pattern to the minification map
 */
export function minifyClass(
  map: MinificationMap,
  semanticName: string,
  classes: string
): MinifiedClass {
  // Check if already minified
  const existing = map.nameToMinified.get(semanticName);
  if (existing) {
    return map.minifiedToData.get(existing)!;
  }

  // Hash for deduplication (same classes = same minified name)
  const hash = hashClasses(classes);

  // Check if identical classes already exist
  for (const [_, data] of map.minifiedToData) {
    if (data.hash === hash) {
      map.nameToMinified.set(semanticName, data.minified);
      return data;
    }
  }

  // Generate new minified name
  let minified: string;
  do {
    minified = generateMinifiedName(map.counter++);
  } while (map.usedNames.has(minified));

  map.usedNames.add(minified);

  const result: MinifiedClass = {
    original: semanticName,
    minified,
    classes,
    hash
  };

  map.nameToMinified.set(semanticName, minified);
  map.minifiedToData.set(minified, result);

  return result;
}

/**
 * Get minified name for a semantic name
 */
export function getMinified(map: MinificationMap, semanticName: string): string | undefined {
  return map.nameToMinified.get(semanticName);
}

/**
 * Get full data for a minified name
 */
export function getFromMinified(map: MinificationMap, minified: string): MinifiedClass | undefined {
  return map.minifiedToData.get(minified);
}

/**
 * Generate CSS from minification map
 */
export function generateMinifiedCSS(
  map: MinificationMap,
  options: {
    framework: 'tailwind' | 'bootstrap' | 'unocss' | 'tachyons' | 'custom';
    includeComments?: boolean;
  } = { framework: 'tailwind', includeComments: false }
): string {
  let css = `/* Generated by classmcp - Ultra-minified CSS */\n\n`;

  const sorted = Array.from(map.minifiedToData.values()).sort((a, b) =>
    a.minified.localeCompare(b.minified)
  );

  for (const data of sorted) {
    if (options.includeComments) {
      css += `/* ${data.original} */\n`;
    }

    if (options.framework === 'tailwind' || options.framework === 'unocss') {
      css += `.${data.minified} { @apply ${data.classes}; }\n`;
    } else {
      // For non-Tailwind, we'd need framework-specific handling
      // This is a simplified version
      css += `.${data.minified} { /* ${data.classes} */ }\n`;
    }
  }

  return css;
}

/**
 * Calculate token savings
 */
export function calculateSavings(map: MinificationMap): {
  totalOriginalTokens: number;
  totalMinifiedTokens: number;
  savingsPercent: number;
  avgSavingsPerClass: number;
} {
  let totalOriginal = 0;
  let totalMinified = 0;

  for (const [_, data] of map.minifiedToData) {
    // Rough token estimate: 1 token per 4 chars + 1 for class=""
    const originalTokens = Math.ceil(data.classes.length / 4) + 3;
    const minifiedTokens = Math.ceil(data.minified.length / 4) + 3;

    totalOriginal += originalTokens;
    totalMinified += minifiedTokens;
  }

  const count = map.minifiedToData.size;

  return {
    totalOriginalTokens: totalOriginal,
    totalMinifiedTokens: totalMinified,
    savingsPercent: count > 0 ? ((totalOriginal - totalMinified) / totalOriginal) * 100 : 0,
    avgSavingsPerClass: count > 0 ? (totalOriginal - totalMinified) / count : 0
  };
}

/**
 * Export map as JSON for persistence
 */
export function exportMap(map: MinificationMap): object {
  return {
    mappings: Array.from(map.minifiedToData.values()),
    counter: map.counter
  };
}

/**
 * Import map from JSON
 */
export function importMap(data: { mappings: MinifiedClass[]; counter: number }): MinificationMap {
  const map = createMinificationMap();
  map.counter = data.counter;

  for (const item of data.mappings) {
    map.nameToMinified.set(item.original, item.minified);
    map.minifiedToData.set(item.minified, item);
    map.usedNames.add(item.minified);
  }

  return map;
}
